
Unsorted
========

Standardize a few more things:
    
    con.isolation_level
    con.transaction_status

Query builders.

    dbx.select('column', dbx.alias('count(1)', 'count'), from_='table').join('table2', on='some condition').where(dbx.or_('foo = {}', 1)).group_by('bar', 'desc')
    dbx.upsert('table', dict(foo='new_value'), where='id = blah')
    dbx.bind('a = {}', 'apple') for generic use around the place

SQL literal should work everywhere.

    dbx.SQL('literal SQL')

Datetime and other parsing should be on by default for SQLite stuff.

Pull in con.tables(), con.columns(table), etc., from mmtransfer.


Connection Management Confusion
===============================

- `get_connection` vs `connect` is not clear, alternatives include:
    - `take_connection` vs `borrow_connection`
    - `auto_connection()`
    - `auto_connect()`
    - `connection_context()`
    - a method vs calling the engine:
        with engine() as con:
            pass
    - calling the pool:
        with engine.pool() as con:
            pass
    x a method vs a direct context:
        # Note that this can't work as I don't think we can really track
        # the state on this to be sure we close it without doing shit like
        # using sys._getframe to maintain it.
        with engine as con:
            pass


Documentation
=============

- In non-autocommit mode, transactions start implicitly, not when you enter
  the context. con.begin() just puts us back into non-autocommit, and doesn't
  start a transaction either.
