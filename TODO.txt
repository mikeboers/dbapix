
Turn everything into wrappers around the raw objects.

    Connection

        ._raw # the real connection

        .closed
        .close()

        .autocommit <> bool
        .isolation_level <> str

        .cursor() -> Cursor

        .__enter__() -> self
        .__exit__(); commit()

        .begin() -> TransactionContext
        .commit()
        .rollback()

        .execute/insert/update/delete
            Pass through.

    Cursor

        ._raw # The real cursor.
        
        .description
        .execute(query, params)

        .insert()
        .update()
        .delete()





Query builders.

    dbx.select('column', dbx.alias('count(1)', 'count'), from_='table').join('table2', on='some condition').where(dbx.or_('foo = {}', 1)).group_by('bar', 'desc')
    dbx.upsert('table', dict(foo='new_value'), where='id = blah')
    dbx.bind('a = {}', 'apple') for generic use around the place

SQL literal should work everywhere.

    dbx.SQL('literal SQL')

Datetime and other parsing should be on by default for SQLite stuff.


Pull in con.tables(), con.columns(table), etc., from mmtransfer.


Documentation
=============

- In non-autocommit mode, transactions start implicitly, not when you enter
  the context. con.begin() just puts us back into non-autocommit, and doesn't
  start a transaction either.
